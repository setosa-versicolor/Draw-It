<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Memory Draw — v10</title>
<style>
  :root{
    --bg:#0b0f14;
    --bg2:#0e141d;
    --panel:#121826;
    --ink:#eaf0fb;
    --muted:#9fb0c8;
    --accent:#60d0ff;
    --accent2:#6ff0b2;
    --good:#37d375; --warn:#ffd166; --bad:#ff6b6b;
    --toolbarH: 56px;
    --railW: 52px;
    --railWopen: 240px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 80% -20%, #142033 0%, #0b0f14 50%);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;overflow:hidden}
  .app{display:flex;flex-direction:column;min-height:100dvh;height:100dvh;overflow:hidden}
  header{
    height:56px;display:flex;align-items:center;justify-content:space-between;
    padding:calc(env(safe-area-inset-top,0) / 2) 12px 0 12px;
    border-bottom:1px solid #1a2331;background:linear-gradient(180deg,#111a2b,#0e1522);
    position:relative;z-index:30;
  }
  .title{font-weight:800;font-size:16px;letter-spacing:.2px;display:flex;align-items:center;gap:8px}
  .title .dot{width:10px;height:10px;border-radius:999px;background:linear-gradient(180deg,var(--accent2),var(--accent))}
  .hcontrols{display:flex;gap:8px;align-items:center}
  button,.btn{
    appearance:none;border:1px solid #263143;background:#121a27;color:var(--ink);
    padding:10px 12px;border-radius:12px;font-weight:700;font-size:13px;letter-spacing:.2px;cursor:pointer;transition:.15s transform ease, .15s opacity ease;
  }
  button:active{transform:translateY(1px)}
  button.primary{background:linear-gradient(180deg,#86ffbf,#60d0ff);color:#07121a;border:0}
  .iconbtn{width:38px;height:38px;border-radius:10px;border:1px solid #1f2734;background:#0f141c;color:#e9eef7;display:grid;place-items:center}
  input[type="file"]{display:none}

  .stage{position:relative;flex:1;min-height:0;background:linear-gradient(180deg,#0a0f16,#0a0f16 60%, #0b121a);display:grid;place-items:center}
  .stage-inner{position:relative;width:100%;height:100%}
  .fill{position:absolute;inset:0}
  .fit{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  .countdown{position:absolute;inset:0;display:grid;place-items:center;font-size:52px;font-weight:900;color:#fff;text-shadow:0 6px 24px #000a;pointer-events:none}
  .center-msg{position:absolute;inset:0;display:grid;place-items:center;text-align:center;padding:20px;color:var(--muted)}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#0c121a;border:1px solid #203047;color:var(--muted);font-size:12px;margin-top:6px}
  .meter{position:absolute;left:12px;right:12px;top:12px;height:6px;background:#0f141c;border:1px solid #1f2a3a;border-radius:99px;overflow:hidden;opacity:0;transition:.2s}
  .meter > span{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent2),var(--accent));}
  .meter.show{opacity:1}

  /* Bottom toolbar */
  .toolbar{
    position:absolute;left:0;right:0;bottom:0;height:var(--toolbarH);
    display:flex;gap:8px;align-items:center;justify-content:space-between;
    padding:8px max(12px, env(safe-area-inset-left,0)) calc(max(env(safe-area-inset-bottom,0), 10px) - 2px) max(12px, env(safe-area-inset-left,0));
    background:linear-gradient(180deg,#0b0f1400,#0b0f14cc 40%,#0b0f14cc);
    backdrop-filter:blur(6px);border-top:1px solid #1b2433; z-index:20;
  }
  .left,.right{display:flex;gap:8px;align-items:center;flex-wrap:wrap}

  /* Tool Rail (right/left dock) */
  .rail{
    position:absolute;top:64px;bottom:calc(var(--toolbarH) + max(env(safe-area-inset-bottom,0), 10px) + 8px);
    right:12px;width:var(--railW);z-index:25;
    display:flex;flex-direction:column;align-items:stretch;gap:8px;
    transition:width .2s ease, right .2s ease, left .2s ease;
  }
  .rail.left{left:12px;right:auto}
  .rail .card{
    background:#0f141c;border:1px solid #1f2a3a;border-radius:14px;padding:8px;
    box-shadow:0 8px 24px #0007;display:flex;flex-direction:column;gap:10px;height:100%;
  }
  .rail.collapsed{width:var(--railW)}
  .rail.expanded{width:var(--railWopen)}
  .rail .handle{
    display:flex;align-items:center;justify-content:center;gap:6px;
  }
  .rail .chev{width:32px;height:32px;border-radius:10px;border:1px solid #1f2734;background:#0f141c;color:#e9eef7;display:grid;place-items:center}
  .rail .dock{width:32px;height:32px;border-radius:10px;border:1px solid #1f2734;background:#0f141c;color:#e9eef7;display:grid;place-items:center}
  .rail .title{font-size:12px;color:var(--muted);font-weight:800;letter-spacing:.3px}
  .slider{width:100%;accent-color:var(--accent)}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .row label{color:var(--muted);font-size:12px}
  .switch{width:38px;height:22px}

  /* Results top bar */
  .result-bar{
    position:absolute;left:0;right:0;top:0;
    display:flex;align-items:center;justify-content:space-between;
    gap:8px;padding:8px max(12px, env(safe-area-inset-left,0)) 8px max(12px, env(safe-area-inset-left,0));
    background:linear-gradient(180deg,#0b0f14cc,#0b0f1400);
    border-bottom:1px solid #1b2230; z-index:22;
  }
  .mini{padding:6px 10px;border-radius:999px;border:1px solid #1f2734;background:#0f141c;color:#d9e2f2;font-weight:700;font-size:12px}
  .legend{position:absolute;right:12px;bottom:calc(var(--toolbarH) + max(env(safe-area-inset-bottom,0),10px) + 72px);background:#0f141c;border:1px solid #1f2734;border-radius:12px;padding:10px 12px;font-size:12px;color:var(--muted);display:none;z-index:22}
  .legend .row{display:flex;align-items:center;gap:6px;margin:4px 0}
  .sw{width:14px;height:14px;border-radius:3px}
  .sw.match{background:#1acc6d}
  .sw.extra{background:#ff6b6b}
  .sw.hint{background:#8892a6}

  /* Settings sheet */
  .sheet{position:fixed;inset:auto 0 0 0;height:auto;max-height:70%;background:#0f141c;border-top:1px solid #1f2734;border-radius:16px 16px 0 0;transform:translateY(100%);transition:.25s transform ease;z-index:50;padding:14px 14px calc(14px + env(safe-area-inset-bottom,0));}
  .sheet.show{transform:translateY(0)}
  .sheet h3{margin:4px 0 10px 0;font-size:14px;color:#cfe2ff}
  .optrow{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
  .optrow small{color:var(--muted)}
  .radio{display:flex;gap:8px;flex-wrap:wrap}
  .radio label{border:1px solid #1f2734;background:#0b1118;padding:8px 10px;border-radius:10px;font-weight:700}
  .footerRow{display:flex;justify-content:flex-end;gap:8px;margin-top:10px}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title"><span class="dot"></span>Memory Draw</div>
    <div class="hcontrols">
      <button id="gearBtn" class="iconbtn" title="Settings">⚙️</button>
      <button id="startBtn" class="primary">Start</button>
    </div>
  </header>

  <div class="stage">
    <div class="meter" id="meter"><span id="meterFill"></span></div>
    <div class="stage-inner">
      <img id="revealImg" class="fit" alt="prompt outline" style="opacity:0;transition:.15s"/>
      <div id="countdown" class="countdown" style="opacity:0">5</div>

      <canvas id="draw" class="fill" aria-label="Draw here" style="display:none"></canvas>
      <canvas id="fx" class="fill" style="pointer-events:none"></canvas>

      <div id="message" class="center-msg">
        <div>
          <div style="font-size:18px;color:#d9e2f2;font-weight:800">Press Start to begin</div>
          <div class="pill">See the outline, then draw from memory.</div>
          <div class="pill">Open <b>⚙️ Settings</b> to pick time & source.</div>
        </div>
      </div>

      <canvas id="resultCanvas" class="fill" style="display:none"></canvas>
      <div id="resultBar" class="result-bar" style="display:none">
        <div>
          <span id="scoreChip" class="mini">Score: —</span>
          <span id="gradeChip" class="mini">—</span>
          <span id="challengeChip" class="mini" style="display:none"></span>
        </div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="legendBtn" class="iconbtn" title="Legend">ℹ️</button>
          <button id="viewToggle" class="iconbtn" title="Cycle view">▸</button>
          <button id="againBtn" class="btn">Again</button>
          <button id="shareBtn" class="btn">Share</button>
        </div>
      </div>

      <div id="legend" class="legend">
        <div class="row"><span class="sw match"></span> Match</div>
        <div class="row"><span class="sw extra"></span> Extra (you drew, not in source)</div>
        <div class="row"><span class="sw hint"></span> Hint (in source, you missed)</div>
      </div>

      <!-- Tool Rail (collapsible, dockable) -->
      <div id="rail" class="rail collapsed">
        <div class="card">
          <div class="handle">
            <button id="railToggle" class="chev" title="Expand/Collapse">⟨⟩</button>
            <button id="railDock" class="dock" title="Dock left/right">⇄</button>
          </div>
          <div id="railBody" style="display:none">
            <div class="title">TOOLS</div>
            <div class="row"><label>Brush</label><span id="brushVal" class="mini">10px</span></div>
            <input id="brush" class="slider" type="range" min="2" max="28" value="10">
            <div class="row"><label>Eraser</label><input id="eraser" class="switch" type="checkbox"></div>
            <div class="row"><label>Stabilizer</label><input id="stabilize" class="switch" type="checkbox" checked></div>
            <div class="row"><label>Detail</label><span id="detailVal" class="mini">80</span></div>
            <input id="detail" class="slider" type="range" min="30" max="120" value="80" />
            <button id="challengeBtn" class="btn">Challenge (3)</button>
          </div>
        </div>
      </div>
    </div>

    <!-- bottom toolbar -->
    <div class="toolbar">
      <div class="left">
        <button id="undoBtn" class="btn">Undo</button>
        <button id="clearBtn" class="btn">Clear</button>
        <button id="exportBtn" class="btn">Export</button>
      </div>
      <div class="right">
        <button id="gradeBtn" class="primary">Submit</button>
      </div>
    </div>
  </div>

  <!-- Settings Sheet -->
  <div id="sheet" class="sheet" role="dialog" aria-modal="true">
    <h3>Settings</h3>
    <div class="optrow">
      <div>
        <div><b>Sound</b></div>
        <small>Beep/haptic feedback</small>
      </div>
      <label><input id="mute" type="checkbox"> Mute</label>
    </div>
    <div class="optrow">
      <div>
        <div><b>Time</b></div>
        <small>How long to view the outline</small>
      </div>
      <div class="radio">
        <label><input type="radio" name="time" value="3000"> 3s</label>
        <label><input type="radio" name="time" value="5000" checked> 5s</label>
        <label><input type="radio" name="time" value="8000"> 8s</label>
      </div>
    </div>
    <div class="optrow" style="align-items:flex-start">
      <div>
        <div><b>Source</b></div>
        <small>Pick what to draw</small>
      </div>
      <div style="display:grid;gap:8px;justify-items:end">
        <button id="randomBtn" class="btn">Random outline</button>
        <label class="btn" style="text-align:center">
          <input id="imgInput" type="file" accept="image/*"> Upload image
        </label>
      </div>
    </div>
    <div class="footerRow">
      <button id="sheetClose" class="btn">Close</button>
    </div>
  </div>
</div>

<script>
(function(){
  // Elements
  const gearBtn = document.getElementById('gearBtn');
  const sheet = document.getElementById('sheet');
  const sheetClose = document.getElementById('sheetClose');
  const timeRadios = [...document.querySelectorAll('input[name="time"]')];
  const mute = document.getElementById('mute');
  const randomBtn = document.getElementById('randomBtn');
  const imgInput = document.getElementById('imgInput');

  const startBtn = document.getElementById('startBtn');
  const revealImg = document.getElementById('revealImg');
  const countdownEl = document.getElementById('countdown');
  const message = document.getElementById('message');
  const meter = document.getElementById('meter');
  const meterFill = document.getElementById('meterFill');

  const drawCanvas = document.getElementById('draw');
  const fxCanvas = document.getElementById('fx');
  const resultCanvas = document.getElementById('resultCanvas');
  const resultBar = document.getElementById('resultBar');
  const scoreChip = document.getElementById('scoreChip');
  const gradeChip = document.getElementById('gradeChip');
  const challengeChip = document.getElementById('challengeChip');
  const viewToggle = document.getElementById('viewToggle');
  const againBtn = document.getElementById('againBtn');
  const legendBtn = document.getElementById('legendBtn');
  const legend = document.getElementById('legend');
  const shareBtn = document.getElementById('shareBtn');

  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const exportBtn = document.getElementById('exportBtn');
  const gradeBtn = document.getElementById('gradeBtn');

  // Rail
  const rail = document.getElementById('rail');
  const railToggle = document.getElementById('railToggle');
  const railDock = document.getElementById('railDock');
  const railBody = document.getElementById('railBody');
  const brush = document.getElementById('brush');
  const brushVal = document.getElementById('brushVal');
  const eraser = document.getElementById('eraser');
  const detail = document.getElementById('detail');
  const detailVal = document.getElementById('detailVal');
  const stabilize = document.getElementById('stabilize');
  const challengeBtn = document.getElementById('challengeBtn');

  // State
  let displayMs = 5000;
  let revealTimer = null;
  let imageReady = false;
  let sourceImageBitmap = null;
  let isPointerDown = false;
  let isErasing = false;
  let path = [];
  const paths = []; // for Undo
  let stageCSSW = 0, stageCSSH = 0;
  let resultViewMode = 0; // 0 overlay, 1 edges, 2 original, 3 your drawing
  let challenge = { active:false, round:0, scores:[], best: parseInt(localStorage.getItem('md_best')||'0',10) };

  // Audio
  let audioCtx;
  function getAudio(){
    if(audioCtx) return audioCtx;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if(Ctx){ audioCtx = new Ctx(); }
    return audioCtx;
  }
  function blip(freq=880, dur=0.05, vol=0.03){
    if(mute.checked) return;
    const ctx = getAudio(); if(!ctx) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.frequency.value=freq; o.type='sine';
    g.gain.value=vol;
    o.connect(g).connect(ctx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); }, dur*1000);
  }

  // Helpers
  function fitContain(containerW, containerH, contentW, contentH){
    const s = Math.min(containerW/contentW, containerH/contentH);
    const w = Math.round(contentW * s);
    const h = Math.round(contentH * s);
    const x = Math.round((containerW - w)/2);
    const y = Math.round((containerH - h)/2);
    return {x,y,w,h};
  }
  function sizeCanvases(){
    const stage = drawCanvas.parentElement;
    const rect = stage.getBoundingClientRect();
    const cssW = Math.max(1, Math.round(rect.width));
    const cssH = Math.max(1, Math.round(rect.height));
    stageCSSW = cssW; stageCSSH = cssH;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    [drawCanvas, resultCanvas, fxCanvas].forEach(c => {
      c.width = Math.floor(cssW * dpr);
      c.height = Math.floor(cssH * dpr);
      c.style.width = cssW + 'px';
      c.style.height = cssH + 'px';
      const ctx = c.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
    });
    redrawAll();
  }
  window.addEventListener('resize', sizeCanvases);
  if(window.visualViewport) visualViewport.addEventListener('resize', sizeCanvases);

  // Drawing (smoothed)
  function redrawAll(){
    const ctx = drawCanvas.getContext('2d');
    ctx.clearRect(0,0,stageCSSW,stageCSSH);
    ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#fff';
    for(const p of paths){
      ctx.lineWidth = p.w;
      ctx.globalCompositeOperation = p.erase ? 'destination-out' : 'source-over';
      smoothStroke(ctx, p.pts);
    }
    ctx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
    ctx.lineWidth = parseInt(brush.value,10);
  }
  function smoothStroke(ctx, pts){
    if(!pts.length) return;
    if(pts.length<3){
      ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
      for(let i=1;i<pts.length;i++){ ctx.lineTo(pts[i].x, pts[i].y); }
      ctx.stroke(); return;
    }
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for(let i=1;i<pts.length-1;i++){
      const cpx = (pts[i].x + pts[i+1].x)/2;
      const cpy = (pts[i].y + pts[i+1].y)/2;
      ctx.quadraticCurveTo(pts[i].x, pts[i].y, cpx, cpy);
    }
    ctx.stroke();
  }

  // Random outline & outline preview
  function randomOutline(){
    const w = 640, h = 480;
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#0b0f14'; ctx.fillRect(0,0,w,h);
    ctx.lineWidth = 8; ctx.strokeStyle = '#ffffff'; ctx.lineCap='round'; ctx.lineJoin='round';
    const theme = Math.floor(Math.random()*4);
    if(theme===0){
      ctx.beginPath(); ctx.arc(w/2,h/2,140,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(w/2-50,h/2-35,20,0,6.28); ctx.stroke();
      ctx.beginPath(); ctx.arc(w/2+50,h/2-35,20,0,6.28); ctx.stroke();
      ctx.beginPath(); ctx.arc(w/2,h/2+5,85,Math.PI*.15,Math.PI-.15); ctx.stroke();
    }else if(theme===1){
      ctx.beginPath(); ctx.rect(w/2-110,h-190,220,150); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w/2-130,h-190); ctx.lineTo(w/2,h-280); ctx.lineTo(w/2+130,h-190); ctx.closePath(); ctx.stroke();
      ctx.strokeRect(w/2-28,h-140,56,100);
      ctx.strokeRect(w/2-80,h-160,50,50);
      ctx.strokeRect(w/2+30,h-160,50,50);
      ctx.beginPath(); ctx.arc(80,80,40,0,6.28); ctx.stroke();
    }else if(theme===2){
      ctx.beginPath(); ctx.rect(w/2-24,h-180,48,120); ctx.stroke();
      for(let i=0;i<5;i++){ ctx.beginPath(); ctx.arc(w/2 + Math.cos(i)*70, h-200 - i*20, 90 - i*10, 0, 6.28); ctx.stroke(); }
      for(let i=0;i<3;i++){ const x=120+i*180, y=90+(i%2)*20; ctx.beginPath(); ctx.arc(x,y,26,0,6.28); ctx.arc(x+30,y+6,22,0,6.28); ctx.arc(x-26,y+10,20,0,6.28); ctx.stroke(); }
      ctx.beginPath(); ctx.moveTo(0,h-80); ctx.lineTo(w,h-80); ctx.stroke();
    }else{
      ctx.beginPath(); ctx.moveTo(w/2,h/2-140); ctx.lineTo(w/2-50,h/2+40); ctx.lineTo(w/2+50,h/2+40); ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.arc(w/2,h/2-50,20,0,6.28); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w/2-50,h/2+40); ctx.lineTo(w/2-80,h/2+80); ctx.lineTo(w/2-20,h/2+70); ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w/2+50,h/2+40); ctx.lineTo(w/2+80,h/2+80); ctx.lineTo(w/2+20,h/2+70); ctx.closePath(); ctx.stroke();
      for(let i=0;i<60;i++){ const x=Math.random()*w, y=Math.random()*h; ctx.beginPath(); ctx.moveTo(x-2,y); ctx.lineTo(x+2,y); ctx.moveTo(x,y-2); ctx.lineTo(x,y+2); ctx.stroke(); }
    }
    return c.toDataURL('image/png');
  }
  function toGray(imgData){
    const d = imgData.data;
    for(let i=0;i<d.length;i+=4){
      const y = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
      d[i]=d[i+1]=d[i+2]=y;
    }
    return imgData;
  }
  function sobel(gray,w,h){
    const d = gray.data, out = new Uint8ClampedArray(w*h);
    const idx=(x,y)=> (y*w+x)*4;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const gx = -d[idx(x-1,y-1)] -2*d[idx(x-1,y)] -d[idx(x-1,y+1)]
                   +d[idx(x+1,y-1)] +2*d[idx(x+1,y)] + d[idx(x+1,y+1)];
        const gy = -d[idx(x-1,y-1)] -2*d[idx(x,y-1)] -d[idx(x+1,y-1)]
                   +d[idx(x-1,y+1)] +2*d[idx(x,y+1)] + d[idx(x+1,y+1)];
        const mag = Math.sqrt(gx*gx + gy*gy);
        out[y*w+x] = mag;
      }
    }
    return out;
  }
  function thresholdEdges(mags, w, h, thr){
    const out = new Uint8ClampedArray(w*h);
    for(let i=0;i<out.length;i++) out[i] = (mags[i] >= thr) ? 255 : 0;
    return out;
  }
  function dilate(map, w, h, iterations=1){
    let cur = map;
    for(let it=0; it<iterations; it++){
      const out = new Uint8ClampedArray(w*h);
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let v=0;
          for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(cur[(y+dy)*w+(x+dx)]>0){ v=255; break; } } if(v) break; }
          out[y*w+x]=v;
        }
      }
      cur = out;
    }
    return cur;
  }
  function edgePreviewDataURL(bmp, detailThr=80){
    const W=640,H=480;
    const c=document.createElement('canvas'); c.width=W; c.height=H;
    const ctx=c.getContext('2d');
    ctx.drawImage(bmp,0,0,W,H);
    const gray = toGray(ctx.getImageData(0,0,W,H));
    const mags = sobel(gray, W, H);
    const edges = thresholdEdges(mags, W, H, detailThr);
    const fat = dilate(edges, W, H, 1);
    const imgData = ctx.createImageData(W,H);
    for(let i=0;i<fat.length;i++){
      const on = fat[i] > 0;
      const p=i*4;
      imgData.data[p+0] = on ? 255 : 11;
      imgData.data[p+1] = on ? 255 : 15;
      imgData.data[p+2] = on ? 255 : 20;
      imgData.data[p+3] = 255;
    }
    ctx.putImageData(imgData,0,0);
    return c.toDataURL('image/png');
  }

  function hardResetDrawing(){
    paths.splice(0, paths.length);
    redrawAll();
    drawCanvas.style.display = 'none';
    resultCanvas.style.display = 'none';
    resultBar.style.display = 'none';
    legend.style.display = 'none';
  }

  // Flow
  function enterReveal(){
    if(!imageReady){
      loadSource(randomOutline()).then(enterReveal);
      return;
    }
    hardResetDrawing();
    message.style.display = 'none';
    countdownEl.style.opacity = '1';
    revealImg.style.opacity = '1';
    meter.classList.add('show');
    meterFill.style.width = '0%';
    const left = timeRadios.find(r=>r.checked)?.value || '5000';
    displayMs = parseInt(left,10);
    countdownEl.textContent = Math.round(displayMs/1000);
    blip(660,0.05,0.03);

    const t0 = performance.now();
    cancelAnimationFrame(revealTimer);
    function tick(t){
      const elapsed = t - t0;
      const p = Math.min(1, elapsed / displayMs);
      meterFill.style.width = (p*100)+'%';
      const left = Math.ceil((displayMs - elapsed)/1000);
      countdownEl.textContent = Math.max(0,left);
      if(elapsed >= displayMs){
        exitRevealEnterDraw();
        return;
      }
      revealTimer = requestAnimationFrame(tick);
    }
    revealTimer = requestAnimationFrame(tick);
  }
  function exitRevealEnterDraw(){
    cancelAnimationFrame(revealTimer);
    meter.classList.remove('show');
    countdownEl.style.opacity = '0';
    revealImg.style.opacity = '0';
    drawCanvas.style.display = 'block';
  }

  // Pointer
  function pointerPos(e){
    const rect = drawCanvas.getBoundingClientRect();
    if(e.touches && e.touches[0]){
      return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    } else {
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
  }
  function beginPath(e){
    e.preventDefault();
    isPointerDown = true;
    const {x,y} = pointerPos(e);
    const pth = [{x,y}];
    path = pth;
    const p = { w: parseInt(brush.value,10), erase: isErasing, pts: pth };
    paths.push(p);
    const ctx = drawCanvas.getContext('2d');
    ctx.lineWidth = p.w;
    ctx.globalCompositeOperation = p.erase ? 'destination-out' : 'source-over';
    if(stabilize.checked){ pth.push({x:x+0.01, y:y+0.01}); }
    redrawAll();
  }
  function drawMove(e){
    if(!isPointerDown) return;
    const {x,y} = pointerPos(e);
    const pts = path;
    if(stabilize.checked && pts.length){
      const last = pts[pts.length-1];
      const k = 0.35;
      pts.push({x: last.x + (x-last.x)*k, y: last.y + (y-last.y)*k});
    } else { pts.push({x,y}); }
    redrawAll();
  }
  function endPath(){ isPointerDown=false; }
  function undo(){ paths.pop(); redrawAll(); }
  function clearAll(){ paths.splice(0, paths.length); redrawAll(); }

  // Scoring (alignment-consistent)
  function edgesFromStageSizedSource(thr){
    const off = document.createElement('canvas');
    off.width = stageCSSW; off.height = stageCSSH;
    const ctx = off.getContext('2d');
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,off.width,off.height);
    const fit = fitContain(stageCSSW, stageCSSH, sourceImageBitmap.width, sourceImageBitmap.height);
    ctx.drawImage(sourceImageBitmap, fit.x, fit.y, fit.w, fit.h);
    const AW = 256; const AH = Math.max(1, Math.round(AW * (stageCSSH / stageCSSW)));
    const small = document.createElement('canvas'); small.width=AW; small.height=AH;
    small.getContext('2d').drawImage(off, 0, 0, AW, AH);
    const g = toGray(small.getContext('2d').getImageData(0,0,AW,AH));
    const mags = sobel(g, AW, AH);
    return { map: thresholdEdges(mags, AW, AH, thr), W: AW, H: AH };
  }
  function edgesFromStageDrawing(thr){
    const AW = 256; const AH = Math.max(1, Math.round(AW * (stageCSSH / stageCSSW)));
    const small = document.createElement('canvas'); small.width=AW; small.height=AH;
    small.getContext('2d').drawImage(drawCanvas, 0, 0, AW, AH);
    const g = toGray(small.getContext('2d').getImageData(0,0,AW,AH));
    const mags = sobel(g, AW, AH);
    return { map: thresholdEdges(mags, AW, AH, thr), W: AW, H: AH };
  }
  function dice(a,b){
    let inter=0, ca=0, cb=0;
    for(let i=0;i<a.length;i++){
      const A=a[i]>0?1:0, B=b[i]>0?1:0;
      inter += (A & B); ca += A; cb += B;
    }
    if(ca+cb===0) return 1;
    return (2*inter)/(ca+cb);
  }
  function renderOverlayAligned(srcEdges, drawEdges, W, H, mode){
    const ctx = resultCanvas.getContext('2d');
    ctx.clearRect(0,0,stageCSSW,stageCSSH);
    const imgData = ctx.createImageData(W, H);
    for(let j=0;j<H;j++){
      for(let i=0;i<W;i++){
        const src = srcEdges[j*W+i] > 0;
        const drw = drawEdges[j*W+i] > 0;
        let r=0,g=0,b=0,a=255;
        if(mode===0){ const match=src&&drw, extra=drw&&!src, hint=src&&!drw;
          if(match){ g=220; } else if(extra){ r=220; } else if(hint){ r=g=b=60; }
        } else if(mode===1){ r=g=b= src ? 255 : 0; }
        else if(mode===2){ r=g=b= src ? 255 : 20; }
        else { r=g=b= drw ? 255 : 20; }
        const p = (j*W + i)*4;
        imgData.data[p]=r; imgData.data[p+1]=g; imgData.data[p+2]=b; imgData.data[p+3]=a;
      }
    }
    const temp = document.createElement('canvas');
    temp.width = W; temp.height = H;
    temp.getContext('2d').putImageData(imgData, 0, 0);
    ctx.drawImage(temp, 0, 0, stageCSSW, stageCSSH);
  }

  function celebrate(score){
    const ctx = fxCanvas.getContext('2d');
    const W = fxCanvas.width, H = fxCanvas.height;
    const parts = [];
    const n = Math.min(180, Math.floor(40 + score));
    for(let i=0;i<n;i++){
      parts.push({ x: Math.random()*W, y: -20-Math.random()*100, vx: (Math.random()-0.5)*2, vy: 1+Math.random()*2, s: 2+Math.random()*4, a: 1, hue: Math.random()*360 });
    }
    let frames = 0;
    function step(){
      frames++;
      ctx.clearRect(0,0,W,H);
      for(const p of parts){
        p.vy += 0.02; p.x += p.vx; p.y += p.vy; p.a -= 0.003;
        ctx.fillStyle = `hsla(${p.hue},90%,60%,${Math.max(0,p.a)})`;
        ctx.fillRect(p.x, p.y, p.s, p.s*2);
      }
      if(frames < 260){ requestAnimationFrame(step); }
      else { ctx.clearRect(0,0,W,H); }
    }
    requestAnimationFrame(step);
    if(navigator.vibrate) navigator.vibrate(80);
  }

  async function grade(){
    const thr = parseInt(detail.value,10);
    const src = edgesFromStageSizedSource(thr);
    const drw = edgesFromStageDrawing(thr);
    const W = src.W, H = src.H;
    const sim = dice(src.map, drw.map);
    const pct = Math.round(sim*100);

    scoreChip.textContent = `Score: ${pct}%`;
    let label='Try Again', cls='bad';
    if(pct>=90){label='A'; cls='good';}
    else if(pct>=80){label='B'; cls='good';}
    else if(pct>=65){label='C'; cls='ok';}
    else if(pct>=50){label='D'; cls='ok';}
    gradeChip.textContent = label;
    gradeChip.className = 'mini ' + cls;

    if(pct>=80) celebrate(pct); else if(navigator.vibrate) navigator.vibrate(40);

    drawCanvas.style.display='none';
    resultCanvas.style.display='block';
    resultBar.style.display='flex';
    resultViewMode = 0;
    viewToggle.textContent = '▸';
    renderOverlayAligned(src.map, drw.map, W, H, resultViewMode);
  }

  // Settings behavior
  gearBtn.addEventListener('click', ()=> sheet.classList.add('show'));
  sheetClose.addEventListener('click', ()=> sheet.classList.remove('show'));
  timeRadios.forEach(r=> r.addEventListener('change', ()=>{}));
  randomBtn.addEventListener('click', async ()=>{
    await loadSource(randomOutline());
  });
  imgInput.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    await loadSource(url);
    URL.revokeObjectURL(url);
  });

  // Rail behavior
  railToggle.addEventListener('click', ()=>{
    const isOpen = rail.classList.contains('expanded');
    if(isOpen){
      rail.classList.remove('expanded'); rail.classList.add('collapsed');
      railBody.style.display='none';
    } else {
      rail.classList.remove('collapsed'); rail.classList.add('expanded');
      railBody.style.display='block';
    }
  });
  railDock.addEventListener('click', ()=>{
    if(rail.classList.contains('left')){
      rail.classList.remove('left');
    } else {
      rail.classList.add('left');
    }
  });
  brush.addEventListener('input', ()=>{
    brushVal.textContent = brush.value + 'px';
    const ctx = drawCanvas.getContext('2d');
    ctx.lineWidth = parseInt(brush.value,10);
  });
  detail.addEventListener('input', ()=>{
    detailVal.textContent = detail.value;
    if(sourceImageBitmap){
      revealImg.src = edgePreviewDataURL(sourceImageBitmap, parseInt(detail.value,10));
    }
  });
  eraser.addEventListener('change', ()=>{ isErasing = eraser.checked; });
  challengeBtn.addEventListener('click', ()=>{
    // simple challenge meta (streamlined): press Start / Submit 3x
    challengeChip.style.display='inline-block';
    challengeChip.textContent = 'Challenge: 0/3';
    challenge = {active:true, round:0, scores:[], best: challenge.best};
  });

  // results controls
  document.getElementById('legendBtn').addEventListener('click', ()=>{
    legend.style.display = legend.style.display === 'block' ? 'none':'block';
  });
  document.getElementById('viewToggle').addEventListener('click', ()=>{
    resultViewMode = (resultViewMode + 1) % 4;
    const thr=parseInt(detail.value,10);
    const src=edgesFromStageSizedSource(thr);
    const drw=edgesFromStageDrawing(thr);
    renderOverlayAligned(src.map, drw.map, src.W, src.H, resultViewMode);
  });
  document.getElementById('againBtn').addEventListener('click', ()=>{
    resultCanvas.style.display='none';
    resultBar.style.display='none';
    paths.splice(0, paths.length); redrawAll();
    message.style.display='grid';
  });
  document.getElementById('shareBtn').addEventListener('click', async ()=>{
    try{
      const combo = document.createElement('canvas');
      combo.width = stageCSSW; combo.height = stageCSSH;
      const cctx = combo.getContext('2d');
      cctx.drawImage(resultCanvas, 0, 0);
      cctx.fillStyle = '#0f141cc0';
      cctx.fillRect(12,12,180,36);
      cctx.fillStyle='#eaf0fb'; cctx.font='bold 16px system-ui'; cctx.fillText(scoreChip.textContent, 22, 36);
      const blob = await new Promise(res=> combo.toBlob(res, 'image/png', 0.95));
      const file = new File([blob], 'memory-draw-result.png', {type:'image/png'});
      if(navigator.canShare && navigator.canShare({files:[file]})){
        await navigator.share({files:[file], title:'Memory Draw', text:'My Memory Draw score!'});
      } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href=url; a.download='memory-draw-result.png'; a.click();
        setTimeout(()=>URL.revokeObjectURL(url),1000);
      }
    }catch(e){ /* ignore */ }
  });

  // bottom toolbar
  undoBtn.addEventListener('click', undo);
  clearBtn.addEventListener('click', clearAll);
  exportBtn.addEventListener('click', ()=>{
    const url = drawCanvas.toDataURL('image/png');
    const a = document.createElement('a'); a.href=url; a.download='memory-draw.png'; a.click();
  });
  gradeBtn.addEventListener('click', ()=>{
    grade();
    if(challenge.active){
      challenge.round++;
      challengeChip.style.display='inline-block';
      challengeChip.textContent = `Challenge: ${challenge.round}/3`;
      if(challenge.round>=3){ challenge.active=false; }
    }
  });

  // Stage pointer listeners
  drawCanvas.addEventListener('mousedown', beginPath);
  drawCanvas.addEventListener('mousemove', drawMove);
  window.addEventListener('mouseup', endPath);
  drawCanvas.addEventListener('touchstart', beginPath, {passive:false});
  drawCanvas.addEventListener('touchmove', drawMove, {passive:false});
  window.addEventListener('touchend', endPath);

  // Image loading
  async function loadSource(url){
    const img = new Image();
    img.src = url; await img.decode();
    sourceImageBitmap = await createImageBitmap(img);
    imageReady = true;
    revealImg.src = edgePreviewDataURL(sourceImageBitmap, parseInt(detail.value,10));
  }

  // Init
  sizeCanvases();
  loadSource(randomOutline()).then(()=>{});
  // default rail collapsed
  rail.classList.add('collapsed');
  railBody.style.display='none';

  // Wire settings sheet open/close
  document.getElementById('gearBtn').addEventListener('click', ()=> sheet.classList.add('show'));
  document.getElementById('sheetClose').addEventListener('click', ()=> sheet.classList.remove('show'));
  document.getElementById('startBtn').addEventListener('click', enterReveal);
})();
</script>
</body>
</html>
