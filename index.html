<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Memory Draw — Outline Mode (v6)</title>
<style>
  :root{
    --bg:#0d1016;
    --panel:#161b22;
    --ink:#e9eef7;
    --muted:#9aa8bd;
    --accent:#4cc3ff;
    --accent2:#63f0a6;
    --good:#37d375; --warn:#ffcc66; --bad:#ff6b6b;
    --toolbarH: 56px;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;overflow:hidden}
  .app{display:flex;flex-direction:column;min-height:100dvh;height:100dvh;overflow:hidden}
  header{
    height:52px;display:flex;align-items:center;justify-content:space-between;
    padding:calc(env(safe-area-inset-top,0) / 2) 10px 0 10px;
    border-bottom:1px solid #212734;background:linear-gradient(180deg,#111622,#0e131d);
  }
  .title{font-weight:700;font-size:16px;letter-spacing:.2px}
  .hcontrols{display:flex;gap:8px;align-items:center}
  button,.btn{
    appearance:none;border:1px solid #2a3140;background:#1a202c;color:var(--ink);
    padding:10px 12px;border-radius:12px;font-weight:700;font-size:13px;letter-spacing:.2px;cursor:pointer;
  }
  button.primary{background:linear-gradient(180deg,#73ffa9,#4cc3ff);color:#0a1014;border:0}
  .ghost{opacity:.75}
  input[type="file"]{display:none}
  .stage{
    position:relative;flex:1;min-height:0;background:#0b0f14;display:grid;place-items:center;
  }
  .stage-inner{position:relative;width:100%;height:100%}
  .fill{position:absolute;inset:0}
  .fit{position:absolute;inset:0;width:100%;height:100%;object-fit:contain}
  .countdown{position:absolute;inset:0;display:grid;place-items:center;font-size:56px;font-weight:900;color:#fff;text-shadow:0 6px 24px #000a;pointer-events:none}
  .center-msg{position:absolute;inset:0;display:grid;place-items:center;text-align:center;padding:20px;color:var(--muted)}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;background:#0c1118;border:1px solid #1e2633;color:var(--muted);font-size:12px;margin-top:6px}
  .meter{position:absolute;left:12px;right:12px;top:12px;height:6px;background:#0f141c;border:1px solid #1f2734;border-radius:99px;overflow:hidden;opacity:0;transition:.2s}
  .meter > span{display:block;height:100%;width:0%;background:linear-gradient(90deg,var(--accent2),var(--accent));}
  .meter.show{opacity:1}
  .badge{padding:6px 10px;border-radius:999px;font-weight:800}
  .good{background:#0f2b1b;color:var(--good)}
  .ok{background:#2a2412;color:var(--warn)}
  .bad{background:#2a1517;color:var(--bad)}
  /* Bottom toolbar */
  .toolbar{
    position:absolute;left:0;right:0;bottom:0;height:var(--toolbarH);
    display:flex;gap:8px;align-items:center;justify-content:space-between;
    padding:8px max(10px, env(safe-area-inset-left,0)) calc(max(env(safe-area-inset-bottom,0), 10px) - 2px) max(10px, env(safe-area-inset-left,0));
    background:linear-gradient(180deg,#0b0f1400,#0b0f14cc 40%,#0b0f14cc);
    backdrop-filter:blur(6px);border-top:1px solid #1b2230; z-index:20;
  }
  .left,.right{display:flex;gap:8px;align-items:center}
  /* Floating controls above toolbar */
  .float-controls{
    position:absolute;left:50%;transform:translateX(-50%);
    bottom:calc(var(--toolbarH) + max(env(safe-area-inset-bottom,0), 10px) + 8px);
    display:flex;gap:10px;align-items:center;z-index:21;
    background:#0f141c; border:1px solid #1f2734; border-radius:999px; padding:8px 12px;
    box-shadow:0 8px 24px #0007;
  }
  .slider{width:160px;accent-color:var(--accent)}
  .slider-compact{width:100px}
  .toggle{display:flex;align-items:center;gap:6px;color:var(--muted);font-size:13px}
  .toggle input{width:38px;height:22px}
  /* prevent page scroll while drawing */
  canvas{touch-action:none}
  .stage{overscroll-behavior:contain}
  @media (max-width: 380px){
    .slider{width:120px}
    .slider-compact{width:90px}
  }
  /* Results top bar (replaces center overlay so visuals stay visible) */
  .result-bar{
    position:absolute;left:0;right:0;top:0;
    display:flex;align-items:center;justify-content:space-between;
    gap:8px;padding:8px max(10px, env(safe-area-inset-left,0)) 8px max(10px, env(safe-area-inset-left,0));
    background:linear-gradient(180deg,#0b0f14cc,#0b0f1400);
    border-bottom:1px solid #1b2230; z-index:22;
  }
  .result-bar .group{display:flex;gap:8px;align-items:center}
  .mini{padding:6px 10px;border-radius:999px;border:1px solid #1f2734;background:#0f141c;color:#d9e2f2;font-weight:700;font-size:12px}
  .iconbtn{width:38px;height:38px;border-radius:10px;border:1px solid #1f2734;background:#0f141c;color:#e9eef7;display:grid;place-items:center}
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">Memory Draw — Outline Mode</div>
    <div class="hcontrols">
      <label class="btn">
        <input id="imgInput" type="file" accept="image/*">
        Upload
      </label>
      <button id="randomBtn" class="btn">Random</button>
      <button id="startBtn" class="primary">Start</button>
    </div>
  </header>

  <div class="stage">
    <div class="meter" id="meter"><span id="meterFill"></span></div>
    <div class="stage-inner">
      <!-- reveal image (OUTLINE) -->
      <img id="revealImg" class="fit" alt="prompt outline" style="opacity:0;transition:.15s"/>
      <div id="countdown" class="countdown" style="opacity:0">5</div>

      <!-- drawing canvas -->
      <canvas id="draw" class="fill" aria-label="Draw here" style="display:none"></canvas>

      <!-- center message -->
      <div id="message" class="center-msg">
        <div>
          <div style="font-size:18px;color:#d9e2f2;font-weight:800">Press Start to begin</div>
          <div class="pill">You’ll see a simple OUTLINE of the image for 5 seconds, then draw from memory.</div>
        </div>
      </div>

      <!-- result view (same stage) -->
      <canvas id="resultCanvas" class="fill" style="display:none"></canvas>
      <div id="resultBar" class="result-bar" style="display:none">
        <div class="group">
          <span id="scoreChip" class="mini">Score: —</span>
          <span id="gradeChip" class="mini">—</span>
        </div>
        <div class="group">
          <button id="viewToggle" class="iconbtn" title="Cycle view">▸</button>
          <button id="againBtn" class="btn">Again</button>
        </div>
      </div>

      <!-- floating controls (brush/eraser + outline detail) -->
      <div class="float-controls" id="floatControls">
        <label style="display:flex;align-items:center;gap:8px;color:var(--muted)">
          Brush <input id="brush" class="slider" type="range" min="2" max="28" value="10">
        </label>
        <label class="toggle">
          <input id="eraser" type="checkbox"> Eraser
        </label>
        <label style="display:flex;align-items:center;gap:8px;color:var(--muted)">
          Detail <input id="detail" class="slider slider-compact" type="range" min="30" max="120" value="80" />
        </label>
      </div>
    </div>

    <!-- bottom toolbar -->
    <div class="toolbar">
      <div class="left">
        <button id="undoBtn" class="btn">Undo</button>
        <button id="clearBtn" class="btn">Clear</button>
      </div>
      <div class="right">
        <button id="gradeBtn" class="primary">Submit</button>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  // Elements
  const imgInput = document.getElementById('imgInput');
  const randomBtn = document.getElementById('randomBtn');
  const startBtn = document.getElementById('startBtn');
  const revealImg = document.getElementById('revealImg');
  const countdownEl = document.getElementById('countdown');
  const message = document.getElementById('message');
  const meter = document.getElementById('meter');
  const meterFill = document.getElementById('meterFill');

  const drawCanvas = document.getElementById('draw');
  const resultCanvas = document.getElementById('resultCanvas');
  const resultBar = document.getElementById('resultBar');
  const scoreChip = document.getElementById('scoreChip');
  const gradeChip = document.getElementById('gradeChip');
  const viewToggle = document.getElementById('viewToggle');
  const againBtn = document.getElementById('againBtn');

  const undoBtn = document.getElementById('undoBtn');
  const clearBtn = document.getElementById('clearBtn');
  const brush = document.getElementById('brush');
  const eraser = document.getElementById('eraser');
  const detail = document.getElementById('detail');
  const gradeBtn = document.getElementById('gradeBtn');

  // State
  let displayMs = 5000;
  let revealTimer = null;
  let imageReady = false;
  let sourceImageBitmap = null;
  let sourceDataURL = null;
  let isPointerDown = false;
  let isErasing = false;
  let path = [];
  const paths = []; // for Undo
  let lastW = 0, lastH = 0;
  let resultViewMode = 0; // 0 overlay, 1 edges, 2 original, 3 your drawing

  // Fixed full-screen sizing
  function sizeCanvases(){
    const stage = drawCanvas.parentElement; // stage-inner
    const rect = stage.getBoundingClientRect();
    const cssW = Math.max(1, Math.round(rect.width));
    const cssH = Math.max(1, Math.round(rect.height));
    if(cssW === lastW && cssH === lastH) return;
    lastW = cssW; lastH = cssH;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    [drawCanvas, resultCanvas].forEach(c => {
      c.width = Math.floor(cssW * dpr);
      c.height = Math.floor(cssH * dpr);
      c.style.width = cssW + 'px';
      c.style.height = cssH + 'px';
      const ctx = c.getContext('2d');
      ctx.setTransform(dpr,0,0,dpr,0,0);
    });
    redrawAll();
  }

  function redrawAll(){
    const ctx = drawCanvas.getContext('2d');
    ctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
    ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#fff';
    for(const p of paths){
      ctx.lineWidth = p.w;
      ctx.globalCompositeOperation = p.erase ? 'destination-out' : 'source-over';
      ctx.beginPath();
      for(let i=0;i<p.pts.length;i++){
        const pt = p.pts[i];
        if(i===0) ctx.moveTo(pt.x, pt.y);
        else ctx.lineTo(pt.x, pt.y);
      }
      ctx.stroke();
    }
    ctx.globalCompositeOperation = isErasing ? 'destination-out' : 'source-over';
    ctx.lineWidth = parseInt(brush.value,10);
  }

  // Random stroke-only image
  function randomOutline(){
    const w = 640, h = 480;
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    ctx.fillStyle = '#0b0f14'; ctx.fillRect(0,0,w,h);
    ctx.lineWidth = 8; ctx.strokeStyle = '#ffffff'; ctx.lineCap='round'; ctx.lineJoin='round';

    const theme = Math.floor(Math.random()*4);
    if(theme===0){
      ctx.beginPath(); ctx.arc(w/2,h/2,140,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(w/2-50,h/2-35,20,0,6.28); ctx.stroke();
      ctx.beginPath(); ctx.arc(w/2+50,h/2-35,20,0,6.28); ctx.stroke();
      ctx.beginPath(); ctx.arc(w/2,h/2+5,85,Math.PI*.15,Math.PI-.15); ctx.stroke();
    }else if(theme===1){
      ctx.beginPath(); ctx.rect(w/2-110,h-190,220,150); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w/2-130,h-190); ctx.lineTo(w/2,h-280); ctx.lineTo(w/2+130,h-190); ctx.closePath(); ctx.stroke();
      ctx.strokeRect(w/2-28,h-140,56,100);
      ctx.strokeRect(w/2-80,h-160,50,50);
      ctx.strokeRect(w/2+30,h-160,50,50);
      ctx.beginPath(); ctx.arc(80,80,40,0,6.28); ctx.stroke();
    }else if(theme===2){
      ctx.beginPath(); ctx.rect(w/2-24,h-180,48,120); ctx.stroke();
      for(let i=0;i<5;i++){ ctx.beginPath(); ctx.arc(w/2 + Math.cos(i)*70, h-200 - i*20, 90 - i*10, 0, 6.28); ctx.stroke(); }
      for(let i=0;i<3;i++){ const x=120+i*180, y=90+(i%2)*20; ctx.beginPath(); ctx.arc(x,y,26,0,6.28); ctx.arc(x+30,y+6,22,0,6.28); ctx.arc(x-26,y+10,20,0,6.28); ctx.stroke(); }
      ctx.beginPath(); ctx.moveTo(0,h-80); ctx.lineTo(w,h-80); ctx.stroke();
    }else{
      ctx.beginPath(); ctx.moveTo(w/2,h/2-140); ctx.lineTo(w/2-50,h/2+40); ctx.lineTo(w/2+50,h/2+40); ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.arc(w/2,h/2-50,20,0,6.28); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w/2-50,h/2+40); ctx.lineTo(w/2-80,h/2+80); ctx.lineTo(w/2-20,h/2+70); ctx.closePath(); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(w/2+50,h/2+40); ctx.lineTo(w/2+80,h/2+80); ctx.lineTo(w/2+20,h/2+70); ctx.closePath(); ctx.stroke();
      for(let i=0;i<60;i++){ const x=Math.random()*w, y=Math.random()*h; ctx.beginPath(); ctx.moveTo(x-2,y); ctx.lineTo(x+2,y); ctx.moveTo(x,y-2); ctx.lineTo(x,y+2); ctx.stroke(); }
    }
    return c.toDataURL('image/png');
  }

  // Edge/outline helpers
  function toGray(imgData){
    const d = imgData.data;
    for(let i=0;i<d.length;i+=4){
      const y = 0.2126*d[i] + 0.7152*d[i+1] + 0.0722*d[i+2];
      d[i]=d[i+1]=d[i+2]=y;
    }
    return imgData;
  }
  function sobel(gray,w,h){
    const d = gray.data, out = new Uint8ClampedArray(w*h);
    const idx=(x,y)=> (y*w+x)*4;
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const gx = -d[idx(x-1,y-1)] -2*d[idx(x-1,y)] -d[idx(x-1,y+1)]
                   +d[idx(x+1,y-1)] +2*d[idx(x+1,y)] + d[idx(x+1,y+1)];
        const gy = -d[idx(x-1,y-1)] -2*d[idx(x,y-1)] -d[idx(x+1,y-1)]
                   +d[idx(x-1,y+1)] +2*d[idx(x,y+1)] + d[idx(x+1,y+1)];
        const mag = Math.sqrt(gx*gx + gy*gy);
        out[y*w+x] = mag;
      }
    }
    return out;
  }
  function thresholdEdges(mags, w, h, thr){
    const out = new Uint8ClampedArray(w*h);
    for(let i=0;i<out.length;i++) out[i] = (mags[i] >= thr) ? 255 : 0;
    return out;
  }
  function dilate(map, w, h, iterations=1){
    let cur = map;
    for(let it=0; it<iterations; it++){
      const out = new Uint8ClampedArray(w*h);
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          let v=0;
          for(let dy=-1;dy<=1;dy++){ for(let dx=-1;dx<=1;dx++){ if(cur[(y+dy)*w+(x+dx)]>0){ v=255; break; } } if(v) break; }
          out[y*w+x]=v;
        }
      }
      cur = out;
    }
    return cur;
  }
  function edgePreviewDataURL(bmp, detailThr=80){
    const W=640,H=480;
    const c=document.createElement('canvas'); c.width=W; c.height=H;
    const ctx=c.getContext('2d');
    ctx.drawImage(bmp,0,0,W,H);
    const gray = toGray(ctx.getImageData(0,0,W,H));
    const mags = sobel(gray, W, H);
    const edges = thresholdEdges(mags, W, H, detailThr);
    const fat = dilate(edges, W, H, 1);
    const imgData = ctx.createImageData(W,H);
    for(let i=0;i<fat.length;i++){
      const on = fat[i] > 0;
      const p=i*4;
      imgData.data[p+0] = on ? 255 : 11;
      imgData.data[p+1] = on ? 255 : 15;
      imgData.data[p+2] = on ? 255 : 20;
      imgData.data[p+3] = 255;
    }
    ctx.putImageData(imgData,0,0);
    return c.toDataURL('image/png');
  }

  async function loadSource(url){
    sourceDataURL = url;
    const img = new Image();
    img.src = url; await img.decode();
    sourceImageBitmap = await createImageBitmap(img);
    imageReady = true;
    const outlineURL = edgePreviewDataURL(sourceImageBitmap, parseInt(detail.value,10));
    revealImg.src = outlineURL;
  }

  // NEW: fully reset drawing & results for a new round
  function hardResetDrawing(){
    paths.splice(0, paths.length);
    redrawAll();
    drawCanvas.style.display = 'none';
    resultCanvas.style.display = 'none';
    resultBar.style.display = 'none';
  }

  // Flow
  function enterReveal(){
    if(!imageReady){
      loadSource(randomOutline()).then(enterReveal);
      return;
    }
    // Clear previous drawing & hide results so every round starts fresh
    hardResetDrawing();

    message.style.display = 'none';
    revealImg.style.opacity = '1';
    countdownEl.style.opacity = '1';
    meter.classList.add('show');
    meterFill.style.width = '0%';
    countdownEl.textContent = '5';

    const t0 = performance.now();
    cancelAnimationFrame(revealTimer);
    function tick(t){
      const elapsed = t - t0;
      const p = Math.min(1, elapsed / displayMs);
      meterFill.style.width = (p*100)+'%';
      const left = Math.ceil((displayMs - elapsed)/1000);
      countdownEl.textContent = Math.max(0,left);
      if(elapsed >= displayMs){
        exitRevealEnterDraw();
        return;
      }
      revealTimer = requestAnimationFrame(tick);
    }
    revealTimer = requestAnimationFrame(tick);
  }

  function exitRevealEnterDraw(){
    cancelAnimationFrame(revealTimer);
    meter.classList.remove('show');
    countdownEl.style.opacity = '0';
    revealImg.style.opacity = '0';
    drawCanvas.style.display = 'block';
  }

  // Drawing
  let isPointerDown = false;
  function beginPath(e){
    e.preventDefault();
    isPointerDown = true;
    const {x,y} = pointerPos(e);
    path = [{x,y}];
    const p = { w: parseInt(brush.value,10), erase: isErasing, pts: path };
    paths.push(p);
    const ctx = drawCanvas.getContext('2d');
    ctx.lineWidth = p.w;
    ctx.globalCompositeOperation = p.erase ? 'destination-out' : 'source-over';
    ctx.beginPath(); ctx.moveTo(x,y);
  }
  function drawMove(e){
    if(!isPointerDown) return;
    const {x,y} = pointerPos(e);
    path.push({x,y});
    const ctx = drawCanvas.getContext('2d');
    ctx.lineTo(x,y); ctx.stroke();
  }
  function endPath(){ isPointerDown=false; }

  function pointerPos(e){
    const rect = drawCanvas.getBoundingClientRect();
    if(e.touches && e.touches[0]){
      return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    } else {
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
  }

  function undo(){ paths.pop(); redrawAll(); }
  function clearAll(){ paths.splice(0, paths.length); redrawAll(); }

  // Scoring
  function sobelBinaryFromCanvasLike(cnv, W=256, H=192, thr=80){
    const tmp = document.createElement('canvas'); tmp.width=W; tmp.height=H;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(cnv, 0, 0, W, H);
    const g = toGray(tctx.getImageData(0,0,W,H));
    const mags = sobel(g, W, H);
    return thresholdEdges(mags, W, H, thr);
  }
  function sobelBinaryFromBitmap(bmp, W=256, H=192, thr=80){
    const tmp = document.createElement('canvas'); tmp.width=W; tmp.height=H;
    const tctx = tmp.getContext('2d');
    tctx.drawImage(bmp, 0, 0, W, H);
    const g = toGray(tctx.getImageData(0,0,W,H));
    const mags = sobel(g, W, H);
    return thresholdEdges(mags, W, H, thr);
  }
  function dice(a,b){
    let inter=0, ca=0, cb=0;
    for(let i=0;i<a.length;i++){
      const A=a[i]>0?1:0, B=b[i]>0?1:0;
      inter += (A & B); ca += A; cb += B;
    }
    if(ca+cb===0) return 1;
    return (2*inter)/(ca+cb);
  }
  function renderOverlayInResult(srcEdges, drawEdges, w, h, mode){
    const ctx = resultCanvas.getContext('2d');
    ctx.clearRect(0,0,resultCanvas.width,resultCanvas.height);
    const R = Math.min(resultCanvas.width/w, resultCanvas.height/h);
    const WW = Math.floor(w*R), HH = Math.floor(h*R);
    const ox = Math.floor((resultCanvas.width - WW)/2);
    const oy = Math.floor((resultCanvas.height - HH)/2);
    const imgData = ctx.createImageData(WW, HH);
    for(let j=0;j<h;j++){
      for(let i=0;i<w;i++){
        const src = srcEdges[j*w+i] > 0;
        const drw = drawEdges[j*w+i] > 0;
        let r=0,g=0,b=0,a=255;
        if(mode===0){
          const match = src && drw, extra = drw && !src, hint = src && !drw;
          if(match){ g=220; }
          else if(extra){ r=220; }
          else if(hint){ r=g=b=60; }
        } else if(mode===1){ r=g=b= src ? 255 : 0; }
        else if(mode===2){ r=g=b= src ? 255 : 20; }
        else { r=g=b= drw ? 255 : 20; }
        const di = ((j*WW)/h|0)*WW + ((i*WW)/w|0);
        const p = di*4;
        imgData.data[p]=r; imgData.data[p+1]=g; imgData.data[p+2]=b; imgData.data[p+3]=a;
      }
    }
    ctx.putImageData(imgData, ox, oy);
  }

  async function grade(){
    const W = 256, H = 192;
    const thr = parseInt(detail.value,10);
    const srcEdges = sobelBinaryFromBitmap(sourceImageBitmap, W, H, thr);
    const drawEdges = sobelBinaryFromCanvasLike(drawCanvas, W, H, thr);
    const sim = dice(srcEdges, drawEdges);
    const pct = Math.round(sim*100);

    scoreChip.textContent = `Score: ${pct}%`;
    let label='Try Again', cls='bad';
    if(pct>=90){label='A'; cls='good';}
    else if(pct>=80){label='B'; cls='good';}
    else if(pct>=65){label='C'; cls='ok';}
    else if(pct>=50){label='D'; cls='ok';}
    gradeChip.textContent = label;
    gradeChip.className = 'mini ' + cls;

    drawCanvas.style.display='none';
    resultCanvas.style.display='block';
    resultBar.style.display='flex';
    resultViewMode = 0;
    viewToggle.textContent = '▸';
    renderOverlayInResult(srcEdges, drawEdges, W, H, resultViewMode);
  }

  // Events
  window.addEventListener('resize', sizeCanvases);
  if(window.visualViewport) visualViewport.addEventListener('resize', sizeCanvases);

  imgInput.addEventListener('change', async (e)=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const url = URL.createObjectURL(f);
    await loadSource(url);
    URL.revokeObjectURL(url);
  });
  randomBtn.addEventListener('click', async ()=>{
    await loadSource(randomOutline());
  });
  startBtn.addEventListener('click', enterReveal);
  detail.addEventListener('input', async ()=>{
    if(sourceImageBitmap){
      revealImg.src = edgePreviewDataURL(sourceImageBitmap, parseInt(detail.value,10));
    }
  });

  // drawing
  brush.addEventListener('input', ()=>{
    const ctx = drawCanvas.getContext('2d');
    ctx.lineWidth = parseInt(brush.value,10);
  });
  eraser.addEventListener('change', ()=>{ isErasing = eraser.checked; });
  undoBtn.addEventListener('click', undo);
  clearBtn.addEventListener('click', clearAll);

  drawCanvas.addEventListener('mousedown', beginPath);
  drawCanvas.addEventListener('mousemove', drawMove);
  window.addEventListener('mouseup', endPath);
  drawCanvas.addEventListener('touchstart', beginPath, {passive:false});
  drawCanvas.addEventListener('touchmove', drawMove, {passive:false});
  window.addEventListener('touchend', endPath);

  gradeBtn.addEventListener('click', grade);
  againBtn.addEventListener('click', ()=>{
    hardResetDrawing();
    message.style.display='grid';
  });
  viewToggle.addEventListener('click', ()=>{
    resultViewMode = (resultViewMode + 1) % 4;
    const labels = ['▸','E','O','Y']; // compact indicator for Overlay/Edges/Original/Your edges
    viewToggle.textContent = labels[resultViewMode];
    const W=256,H=192, thr=parseInt(detail.value,10);
    const sc=document.createElement('canvas'); sc.width=W; sc.height=H;
    const sctx=sc.getContext('2d'); sctx.drawImage(sourceImageBitmap,0,0,W,H);
    const srcEdges=thresholdEdges(sobel(toGray(sctx.getImageData(0,0,W,H)),W,H),W,H,thr);
    const dc=document.createElement('canvas'); dc.width=W; dc.height=H;
    const dctx=dc.getContext('2d'); dctx.drawImage(drawCanvas,0,0,W,H);
    const drawEdges=thresholdEdges(sobel(toGray(dctx.getImageData(0,0,W,H)),W,H),W,H,thr);
    renderOverlayInResult(srcEdges, drawEdges, W, H, resultViewMode);
  });

  // Init
  sizeCanvases();
  loadSource(randomOutline()).then(()=>{});
})();
</script>
</body>
</html>
